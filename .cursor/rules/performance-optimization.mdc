
---
alwaysApply: true
---

# 성능 최적화 가이드라인

## 이미지 최적화

### 항상 Next.js Image 컴포넌트 사용
```typescript
import Image from 'next/image'

// 좋음
<Image 
  src="/photo.jpg" 
  alt="설명"
  width={800}
  height={600}
  priority // 첫 화면 이미지용
/>

// 외부 이미지의 경우 next.config.js에서 설정
```

### 이미지 모범 사례
- 첫 화면 이미지(LCP)에 `priority` prop 사용
- 레이아웃 이동 방지를 위해 `width`와 `height` 지정
- 반응형 이미지에는 `fill`과 `sizes` 사용
- 외부 이미지를 위해 `next.config.js`에서 `remotePatterns` 설정

## 폰트 최적화

### next/font 사용
```typescript
import { Inter, Roboto_Mono } from 'next/font/google'

const inter = Inter({ 
  subsets: ['latin'],
  display: 'swap',
  variable: '--font-inter'
})

// 레이아웃에 적용
<html className={inter.variable}>
```

### 폰트 모범 사례
- 가능하면 가변 폰트 사용
- 중요한 폰트 미리 로드
- FOIT 방지를 위해 `display: 'swap'` 사용

## 코드 분할 및 동적 Import

### 무거운 컴포넌트의 동적 Import
```typescript
import dynamic from 'next/dynamic'

// SSR 없는 클라이언트 컴포넌트
const HeavyComponent = dynamic(() => import('@/components/heavy-component'), {
  ssr: false,
  loading: () => <div>로딩 중...</div>
})

// named export와 함께
const Chart = dynamic(
  () => import('@/components/chart').then(mod => mod.Chart),
  { loading: () => <Skeleton /> }
)
```

### 동적 Import 사용 시기
- 대용량 라이브러리 (차트, 에디터, 지도)
- 초기 로드 시 보이지 않는 컴포넌트
- 클라이언트 전용 컴포넌트
- 모달/다이얼로그 콘텐츠

## 데이터 페칭 최적화

### 병렬 데이터 페칭
```typescript
// 좋음 - 병렬 페칭
async function Page() {
  const [posts, users] = await Promise.all([
    fetchPosts(),
    fetchUsers()
  ])
}

// 나쁨 - 순차 페칭
async function Page() {
  const posts = await fetchPosts()
  const users = await fetchUsers() // posts를 기다림
}
```

### 캐싱 전략
```typescript
// 1시간마다 재검증
fetch('https://api.example.com/data', { 
  next: { revalidate: 3600 } 
})

// 캐시 안 함 (항상 최신)
fetch('https://api.example.com/data', { 
  cache: 'no-store' 
})

// 영구 캐시
fetch('https://api.example.com/data', { 
  cache: 'force-cache' 
})
```

## 컴포넌트 최적화

### 비용이 많이 드는 컴포넌트에 React.memo
```typescript
import { memo } from 'react'

export const ExpensiveComponent = memo(function ExpensiveComponent({ data }) {
  // 비용이 많이 드는 렌더링 로직
  return <div>{/* ... */}</div>
})
```

### 클라이언트 컴포넌트 신중하게 사용
- 인터랙티브 컴포넌트를 작게 유지
- 큰 컴포넌트를 서버 + 클라이언트 부분으로 분리
- 서버 컴포넌트를 클라이언트 컴포넌트의 children으로 전달

## 번들 크기 최적화

### Import 크기 확인
- Tree-shakeable import 사용
- bundlephobia.com에서 패키지 크기 확인
- 가벼운 대안 고려

```typescript
// 좋음 - tree-shakeable
import { format } from 'date-fns/format'

// 나쁨 - 전체 라이브러리 import
import dateFns from 'date-fns'
```

## 스트리밍 및 Suspense

### 느린 데이터에 스트리밍 사용
```typescript
import { Suspense } from 'react'

export default function Page() {
  return (
    <>
      <Header />
      <Suspense fallback={<LoadingPosts />}>
        <Posts />
      </Suspense>
      <Suspense fallback={<LoadingComments />}>
        <Comments />
      </Suspense>
    </>
  )
}
```

## 프로덕션 체크리스트
- [ ] next/image로 이미지 최적화
- [ ] next/font로 폰트 로드
- [ ] 무거운 컴포넌트 동적 import
- [ ] 적절한 캐싱 전략 구현
- [ ] 번들 크기 확인 및 최적화
- [ ] Lighthouse 점수 > 90
